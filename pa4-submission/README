README file for Programming Assignment 4 (C++ edition)
======================================================

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code.  Just edit this file.

	good.cl and bad.cl test a few features of the semantic checker.
	You should add tests to ensure that good.cl exercises as many
	legal semantic combinations as possible and that bad.cl
	exercises as many kinds of semantic errors as possible.

	semant.h contains declarations and definitions for the semantic
	analyzer.  Place class definitions for the structures you will
	use here.

        cool-tree.h, and cool-tree.handcode.h specify and give an
        implementation of Cool ASTs (see the README for PA3 and the
        "Cool Tour").  In this assignment, you will need to add
        functions to the AST classes to store, fetch, and compute
        information about the AST.

   	You should NOT remove any definitions that are already present
	in cool-tree.h and cool-tree.handcode.h.  These functions and
	data members are required for the system to function properly.

        You should add any fields and methods to the classes you need to 
	perform semantic analysis.  You	will need to add, for example, 
	methods which traverse the expressions of the tree and implement 
	the type-checking rules.

	semant.cc is the file in which you should write your semantic
	analyzer.  The main() procedure calls the method `semant'
	on `ast_root', the root of the abstract syntax tree generated by
	the parser.  There are methods supplied that you should use to report 
	errors. You are relatively free in how you decide to structure the 
	semantic checker, but don't modify the error printing routines.

	Do not modify any other file.

Instructions
------------

	To compile your semantic analyzer program type:

	% make

	This produces an executable named "semant" which is standalone
	phase of the Cool compiler. The semantic analyzer executable
	accepts as input the output of the parser phase, so in order 
	to test it, you'll need to copy a lexer and a parser into the
	directory: either your own lexer and parser from the previous
	assignments, or the lexer and parser from the reference
	implementation of the compiler.

	To run your checker on the files good.cl and bad.cl type:

	% make dotest

    If you think your semantic checker is correct and behaves like
    the one we wrote, you can try it out by replacing the semantic
    checker in the reference compiler with your own lexer. Just copy
    your compiled semantic binary from this assignment into the
    directory where the reference compiler is.

    To submit your solution, run:

    % make zip

    Check the resulting zip file to make sure it contains everything
    it should. Then submit it on Gradescope.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA4
----------------

1. Explain design decisions, explain why your code is correct, and
	why your test cases are adequate.

I really liked the approach Professor Epstein showed in the lecture for representing the inheritance hierarchy as an augmented Tree. I wrote a class called `InheritanceTree` which has a `std::map` of `Symbol` to `ClassNode` (i.e. tree nodes for `Classes` which hold `Class_`). I decided to use `map` to simplify the amount of code that would have to be written to perform lookups on the tree and class ancestors. I didn't have to use it, but it was the more flexible approach, and the map could easily be swapped out for a hash table if need be for faster lookups. 

As Professor Epstein explained in class, doing a DFS preorder traversal, number each node with its starting time in the tag member of the `ClassNode`. Then, recursively take the max subclass of each nodes' children and assigned it to the `max_subclass` member of the `ClassNode`. This allows easily checking whether a node inherits from another in the `descends_from` function by checking whether the descendant's `tag` is greater than or equal to the potential ancestors `tag`, and less than or equal to the potential ancestors `max_subclass`. 

Implementing Least Common Ancestor was also pretty straight forward. My thinking was to take class A and walk up the inheritance hierarchy while checking for when class B descends from an ancestor of A. Eventually, they would both descend from at least Object.

The `InheritanceTree` also provides an easy way to check for inheritance cycles. I reasoned that if a Class should be in the tree (i.e. didn't cause a previous error) and can't be reached by walking down from the tree root (i.e. from Object) then the Class is in a disconnected component that doesn't inherit from Object. This would indicate an inheritance cycle since in one, Classes mutually inherit from only each other. So all that has to be done is to check which classes are in the map but not reachable from the root of the `InheritanceTree`. 

The `InheritanceTree` functions as the `SymbolTable` for the global scope and what I would use for checking whether classes and features (which are easily accessible in `Class_`) were defined or redefined incorrectly. Using the terminology of the Cool manual, the Class and Method Environments are represented by the data stored by the `InheritanceTree`. I combined this with the strategy of using the provided `SymbolTable` class for creating the Object Environment, i.e. I would use the `InheritanceTree` to load ancestor attributes and ancestor methods when checking a class, do the necessary error checks, and then store the ancestor attributes in the `SymbolTable's` initial scope so they would be accessible when calling `lookup`. All formals, attributes, and other scoped variables (let, case, etc.) would be saved in the `SymbolTable`. When I say "the SymbolTable" I mean a singleton for the entire semantic analyzer. The `InheritanceTree` and SymbolTable singletons are both stored in `ClassTable` which is global to the semantic analyzer and accessible anywhere. I believe that splitting up responsibility between the `InheritanceTree` and the `SymbolTable` was an easier and more flexible approach for scope checking given the effort I put into building the InheritanceTree before implementing the `SymbolTable`. A nice thing about the SymbolTable is being able to use probe() to check for redefinitions of Symbols in the given scope.

So, the general procedure that my semantic analyzer goes through is to first create the `InheritanceTree`, make sure the inheritance hierarchy is well formed and that the classes are correct, and then start iterating over Classes, add the Class' ancestors' attributes into the symbol table, check the Class' methods and attribute definitions for errors (including incorrect redefinitions from ancestors), and then proceed to type check the Class' attributes and methods. 

While type_checking the attributes and methods, the expressions that they contain are type checked as well. Thus, type checking is done by creating virtual functions for the provided base classes: Feature_class, Expression_class, and Case_class defined in cool-tree.h and cool-tree.handcode.h. The `type_check` function accepts a `Class_` argument for the Class which is currently being type checked, and returns a `Symbol` which is the type that the feature, expression, or case is determined to be. Passing the current class to all type_check calls enabled more informative errors (class__class contains the filename for use in semant_error) and is necessary for a particular instance I had to debug when running on the Cool examples' code: I found out that SELF_TYPE was being searched in the InheritanceTree though it would never populate it (since it is a Symbol and not a Class_) and was causing the program to panic. I had to put a check that replaced SELF_TYPE with the current class in the `self_type_convert` function in order to prevent such errors. 

The type-checking rules were implemented based on the ones in the cool-manual. Many of them were straight forward, though I had to iteratively check for the errors that the refimpl outputted to add them to the type_check implementations. Accounting for SELF_TYPE was also a caveat, but I addded a check for it in match_eval_type (which checks whether an expression's type assigned type matches its evaluated type) because it is so pervasive in the rules. 

Ultimately, I know that my semantic analyzer wont output the errors in the same order as the refimpl, or probably all of the errors that its supposed to (though I tried to cover as many cases as I feasibly could) it's output matches the refimpl for the example Cool programs, which I think is Cool.